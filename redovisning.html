<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8">
<title>Redovisning av kursmoment i kursen javascript1</title>
<link rel="stylesheet" href="style/style.css">
<link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
</head>

<body>

    <div class="container">
    <h2 class="text-center"> Redovisningar </h2>
    <p><strong>Nedan ser ni alla mina redovisningar. </strong></p>
    <div class="panel-group" id="redovisnings-grupp">
    <div class="panel panel-default">
    <div class="panel-heading">
    <h4 class="panel-title">
    <a data-toggle="collapse" data-parent="#redovisnings-grupp" href="#Kmom01">Kmom01</a>
    </h4>
    </div>

    <div id="Kmom01" class="panel-collapse collapse">
    <div class="panel-body">
    <div class="row">
    <h2 class="lead strong"> "En me-sida i JS" </h2>
    <ul>
    <li><b>Vilken utvecklingsmiljö använder du?</b></li>
    Jag använder mig av den utvecklingsmiljö som föreslogs (Atom), Chrome.
    Utöver det så använder jag mig av w3schools, SO, Google och Mdn för fortsatt fördjupning inom frågor.
    Jag funderade på att använda mig utav sublime text 3, vilket jag gjort tidigare i webbutvecklingssyfte, men det blev till att köra vidare med Atom som jag använder i Python kursen.

    <li><b>Är du bekant med HTML, CSS och JavaScript sedan tidigare?</b></li>
    Yes, absolut. Jag använder HTML och CSS ofta på jobbet då man ASP.NET i princip bygger på samma princip.
    Javascript använder jag lite mer sällan. Dock är det en språk som jag velat komma igång med ganska länge.
    Jag har kört igenom större delen av FCC (Free Code Camp) front-end certificate, som då bygger på HTML, CSS och JS (huvudsakligen jQuery).
    HTML5 är dock något som jag inte rört alltför mycket. En del CSS3 har jag lekt med, som kan ses på min portfolio sida.

    <li><b>Gick det bra med JSFiddle? Länka till din JSFiddle.</b></li>
    Jodå, JSFiddle är något jag lekt med tidigare också. Om inte annat har man sett JSFiddle använt på SO rätt ofta.
    Helt sjukt behändig hemsida som gör det riktigt enkelt för utvecklare att finna och visa lösningar för andra personer som
    annars kanske kan ha lite problem. Utöver JSFiddle har jag lekt en hel del med CodePen, vilket då också använts i FCC-kurserna.

    <br><span class="lead"><a href="https://jsfiddle.net/uj6fd7s5/">JSFiddle</a></span>.

    <li><b>Är du bekant med terminalen och Unix-kommandon sedan tidigare?</b></li>
    Bekant kan jag nog säga att jag är. Dock är jag inte särskilt bekväm med terminalen som
    jag kanske borde vara... Iom att vi huvudsakligen jobbar med .NET så sitter vi i
    Windows-miljö, vilket inte riktigt kräver någon större erfarenhet av terminalen..
    Jag jobbar på att bli mer van vid den, dock. Vilket Python kursen garanterat lärt mig mer av.
    Om inte annat är termainal-kunskap en färskvara, så det gäller att hålla vara på dem!

    <li><b>Gick det bra att komma i gång med kursmomentet, var det lagom, för litet, för stort?</b></li>
    Jo, men det tror jag.
    Jag lyckades missa en liten del (init). Men annars än det så har det
    inte varit något större bekymmer annat än svenskan. Jag är född och
    uppväxt i Sverige, men jag pratar inte svenska särskilt ofta och
    har varken pratat, läst eller skrivit svenska regelbundet sedan jag åkte till Korea.
    </ul>
    </div>
    </div>
    </div>
    </div>
    <div class="panel panel-default">
    <div class="panel-heading">
    <h4 class="panel-title">
    <a data-toggle="collapse" data-parent="#redovisnings-grupp" href="#Kmom02">Kmom02</a>
    </h4>
    </div>
    <div id="Kmom02" class="panel-collapse collapse">
    <div class="panel-body">
    <ul>

    <li><b>Har du programmerat i JavaScript tidigare?</b></li>
    Som nämnt ovan så har jag jobbat lite med Javascript tidigare. Huvudsakligen så har jag jobbat
    mig igenom FCC's front-end certificate vilket går (gick) igenom algoritmer och best practice.
    Men jag har även jobbat med JS vid sidan av mitt nuvarande jobb, som ni kan se på min profil-sida
    som är länkad i min me.html-fil.
    Sen jobbar jag ibland med JS för att utöka användbarheten av mina program här på jobbet, även
    fast det ofta är lite overkill då de flesta funktioner redan är uppfyllda.
    Klart det är kul att lära sig mer JS, dock. Riktigt bra språk att kunna i den nuvarande marknaden! :)

    <li><b>Vad tycker du är det svåraste, mest utmanande i utveckling med HTML, CSS och JavaScript - så här långt?</b></li>
    Hittils har det inte varit alltför utmanande. Jag har aldrig jobbat med specifika events, dvs att jag inte riktigt
    hållt på alltför mycket med att läsa vilka/vilken tangent osv som blivit nertryckt. Detta för att jag huvudsakligen
    gjort rätt traditionella hemsidor när jag jobbat med JS.
    Om vi talar rent generellt om mina erfarenheter av html, css och js så måste jag ändå påstå att den största
    utmaningen jag gått igenom har varit min portfolio-hemsida, vilken fortarande inte är klar, har helt enkelt inte
    haft tid nog att lösa den.

    Ofta kan jag tycka att utveckla lösningar som är fullkomligt responsiva kan vara det mest utmanande. Speciellt
    då det är så många ramverk som kommer ut som ksa lösa det så "lätt" som möjligt. Detta gör det svårt
    att sovra igenom dem för att hitta vad som bäst funkar för just dig.

    <li><b>Hur gick det att utföra respektive uppgift, vilken tog mest tid och vilken var mest lärorik?</b></li>
    Jag tycker nog att flaggan(orna) var den roligaste och mest utmanande. Huvudsakligen för att jag fick leka
    lite med flex-box för att skapa ordentliga kvadrater i flaggan (Chile).
    Det var inte alltför svårt, men rätt kul och lärorikt. Tänkte att jag skulle leka med flex-box eftersom
    jag annars brukar leka med bootstrap och många säger att man ska röra sig mtoe just flex-box. :)


    </ul>
    </div>
    	</div>
    	</div>
        			<div class="panel panel-default">
    				    <div class="panel-heading">
    					    <h4 class="panel-title">
    					    <a data-toggle="collapse" data-parent="#redovisnings-grupp" href="#Kmom03">Kmom03</a>
    					    </h4>
    				    </div>
    				    <div id="Kmom03" class="panel-collapse collapse">
    				    	<div class="panel-body">
    				    			<ul>

    								    <li><b>Har du programmerat med funktioner tidigare, känns det lätt eller svårt?</b></li><br><br>
                                        Jo, det har jag. Jag har tidigare programerat i ett par språk, men jag gillar verkligen hur man strukturerar funktioner i Javascript (och Java).<br>
                                        Ett problem jag hade med Python är att det inte känns 'strikt' på samma sätt; det känns inte lika lättläst eftersom man använder sig utav indentering<br>
                                        istället för specifika taggar som börjar / avslutar en funktionskropp. <br>
                                        Dessutom gillar jag att man kan nästla funktioner i funktioner i JS, vilket jag inte riktigt gjort (eller om det är möjligt) i Java.<br>
                                        <br>
                                        <li><b>Vad tycker du om video som läromedel, tycker du att de tillför något som läromedel?</b></li><br><br>
                                        Jag gillar videor som läromedel skarpt. Jag pluggar rätt mycket när jag är på gymmet, vilket kan göra det lite halvsvårt att läsa samtidigt som man exempelvis lyfter vikter.<br>
                                        Dock så är det ett tve-eggat svärd; om de är bra och relevanta så är det ett väldigt bra läromedel (alltså om de behandlar relevanta ämnen), om de däremot<br>
                                        inte är relevanta till vad man jobbar med eller om de inte täcker subjektet / svärvar ut så finns det en stor risk att det istället blir väldigt omständigt.<br>
                                        En bra sak att tänka på med videor är att ha en inledning där man visar var olika moduler hanteras! :)<br>
                                        <br>
                                        <li><b>Vad tyckte du om de olika uppgifterna? Hur tänkte du när du utförde dem? Var de svåra eller lätta?</b></li><br><br>
                                        Jag tyckte de var bra. Jag gillade inte att man skulle använda sig av det exemplet som uppgiftsbeskrivnigen krävde, utan istället valde jag att spinna vidare på min <br>
                                        tidigare baddie(1), där jag redan hade specificerat funktioner och hantering på ett rätt bra sätt. <br>
                                        Huvudsakligen valde jag att använda mig utav rätt hård-kodade värden för diverse saker (width, height i boxen exempelvis), samt att jag använder mig av transforms / transitions<br>
                                        för rörelse(r). <br><br>

                                        Jag valde även att lägga till en 'jump' som hanteras via 'space'. Detta ökar storleken på min baddie och flyttar honom något på y-axeln och sedan går tillbaka till sin <br>
                                        orginalposition via en transition (ease). <br><br>

                                        Uppgifterna var inte alltför svåra, utan rätt grundläggande. Jag har en del erfarenhet av JS som sagt, så det var inga större svårigheter. Jag är inte säker på att jag <br>
                                        gillar att vi inte kan arbeta med jQuery eftersom det är ett sådant relevant ramverk, speciellt i England. Dock förstår jag resoneringen då vi ska lära oss<br>
                                        hur man arbetar med JS mer specifikt. <br>
                                        <br>

    				    		   </ul>
    			    		</div>
        				</div>
        			</div>

        			<div class="panel panel-default">
    				    <div class="panel-heading">
    					    <h4 class="panel-title">
    					    <a data-toggle="collapse" data-parent="#redovisnings-grupp" href="#Kmom04">Kmom04</a>
    					    </h4>
    				    </div>
    				    <div id="Kmom04" class="panel-collapse collapse">
    				    	<div class="panel-body">
    				    			<ul>

    								    <li><b>Hur kändes det att bekanta sig med begreppet array??</b></li>
                                        <br>
                                        Det kändes överlag rätt bra. Jag har tidigare jobbat i både Javascript och Java, så det blev en lätt övergång.<br>
                                        Jag måste dock påstå att jag föredrar hur det känns att arbeta i arrayer mot hur det funkar i Python. Huvudsakligen<br>
                                        för att jag föredrar hur det känns att jobba med funktioner och prototyper. Det är härligt att kunna skapa funktioner för<br>
                                        specifika datatyper iom att det gör hela utvecklingsprocessen betydligt mer dynamisk, och därmed roligare!<br>
                                        <br><br>
                                        Men även fast det känns bättre att jobba med arrayer i Javascript så saknar jag hur enkelt det var att gå mellan strängar<br>
                                        och arrayer (listor) i Python. Ett väletablerat exempel är man så enkelt kan använda slice på samma sätt i en array som <br>
                                        i en sträng i Python, vilket jag saknar. Som nämnt ovan känns det dock rätt skönt att vara tillbaka till funktioner.<br>
                                        <br>
                                        <li><b>Hur kändes det att bekanta sig med begreppet objekt?</b></li>
                                        <br>
                                        Det här var lite svårare än vad jag är van vid. Jag har ju som nämnt ovan jobbat i JS och java, så <i>begreppet</i> 'objekt'<br>
                                        är absolut inte främande för mig. Men jag är van vid att köra explecita objektanrop (var kalle = new Person();). Dock så<br>
                                        jobbade vi lite annorlunda denna gången, med Object.Create() vilket kändes lite fippligt i början, men däremot känns underbart nu!<br>
                                        <br>
                                        Jag försökte jobba från ett mer objektorienterat perspektiv under uppgifterna också, så objekten är betydligt mer dynamiska än<br>
                                        man annars kanske kan tänka sig att de ska vara - som ni säkert kommer se. Jag pratade med Andreas om det, för att säkerställa att<br>
                                        det var OK, vilket det var!<br>
                                        <br>
                                        <li><b>Hur gick det att utföra uppgifterna, vilken tog mest tid och vilken var mest lärorik?</b></li>
                                        <br>
                                        Jag gillade baddie. Den kändes bra. Som ni säkert kommer se i koden så har jag i princip tagit bort ALL kod som ni hade i exempelkoden.<br>
                                        Detta gjorde jag för att jag ville lära mig lite mer om hur man kan arbeta med javascript och HTML. Det kändes liksom inte rätt att arbeta<br>
                                        på er exempelkod när jag skulle lära mig mer om jag gjorde om allt från grunden upp.<br>
                                        <br>
                                        Jag skippade att göra planen större, då det helt ärligt inte hade gett mig något mer rent erfarenhetsmässigt - det handlar ju egentligen bara<br>
                                        om att öka storleken på planen samt antalet tiles. Så det kändes mest som något som kan vara bra om man inte greppat hur HTML och CSS fungerar.<br>
                                        <br>
                                        Istället fokuserade jag mig på att arbeta med events och trigger-events. Som ni säkert kommer se så har jag lagt in ett litet moment i mitt spel<br>
                                        där man som spelare måste flytta på en låda och ställa den på en 'pressure-plate' för att kunna öppna dörren och därmed avsluta spelet!<br>
                                        <br>
                                        Förhoppningsvis kommer det vara lite halvkul att spela (åtminstone i ett par sekunder...). :D
                                        <br>
                                        <li><b>Svårigheter, lärdomar </b></li><br>
                                        Som nämnt ovan så var det lite nytt att jobba med objekt på det 'nya' sättet. Jag är dock inte säker på utifall jag tror det kommer bli en ny standard<br>
                                        för hur man kommer jobba med objekt i Javascript. Det verkar som att communityt är rätt delat kring frågan.<br>
                                        Det kan dock säkerligen finnas goda anledningar till att ha Object.create(). Jag gillade det skarpt när man väl förstod hur man ska arbeta med dem.<br>
                                        Men gillar jag det mer än jag gillar att köra <i><b>object o = new object(foo, bar);</b></i>? Tveksamt. Jag förstår bägge och kan se användningsområden för<br>
                                        bägge två.<br><br>

                                        Något särskilt svårt var det väl inte i detta kursmoment. Jag kan dock se att många kan tycka det blir lite svårt ju djupare man går med objekt. <br>
                                        Det är ju självklart en 'sån där' aspekt som man inte kan skippa att lära sig och som tveklöst kan bli så avancerat som man vill att det ska vara.<br>
                                        Det ska bli kul att se hur många som fastnar lite på kmom03 och kmom04. Speciellt då jag känner att svårighetsgraden har ökat märkvärt från kmom02. <br>
    				    		   </ul>
    			    		</div>
        				</div>
        			</div>

    <div class="panel panel-default">
        <div class="panel-heading">
            <h4 class="panel-title">
            <a data-toggle="collapse" data-parent="#redovisnings-grupp" href="#Kmom05">Kmom05</a>
            </h4>
        </div>
        <div id="Kmom05" class="panel-collapse collapse">
            <div class="panel-body">
                    <ul>

                        <li><b>Hur upplevde du labben, var något svårt eller utmanande?</b></li><br><br>
                        Jag kan inte riktigt påstå att labben var särskilt utmanande eller svår. Men jag gillade den verkligen! Det var lärorikt att arbeta med DOM-element och events, speciellt då jag faktiskt<br>
                        aldrig riktigt gjort det på egen hand.<br>
                        En sak som var lite mer utmanande än jag själv hade tänkte det skulle vara var att komma åt grundelementet när man börjat lägga till nya element. I vissa fall så<br>
                        visade det sig att jag antingen inte kunde ändra grundelementet eller inte kunde ändra dess barn. Dock löste det sig relativt snabbt med lite hjälp från<br>
                        Emil i Gitter.<br>
                        En annan sak som var lite udda var hur JS fungerar med inline-styling, något som jag själv aldrig riktigt jobbat med tidigare. Ett exempel var när jag<br>
                        arbetade med färgerna. Eftersom vi skulle arbeta med en klass 'green' för att sätta färgen på grundelementet så verkade det inte som att element.style.backgroundColor<br>
                        reagerade på 'klass'-färgen, då inline-stylen inte var satt. Så när jag skulle ändra färgen i min switch-sats (case "green" exempelvis), så var alltså<br>
                        background-color (inline): "";<br><br>

                        Det  var helt enkelt en rätt intressant uppgift då vi verkligen rörde vid ämnen jag aldrig riktigt jobbat med tidigare och med saker som jag annars <b>antagit</b> hade varit<br>
                        annorlunda (som ovan nämnda exemplet med färger). Jag har ju ett par år i nacken, men det var helt klart en god labb som lärde mig en heeeel del!<br><br>

                        <li><b>Beskriv vad du gjorde som sista uppgift i labben. </b></li><br><br>

                        Som sista uppgift valde jag att göra något någorlunda utmanande samt jobba lite med saker som var i linje med vad vi gjort under uppgiften.<br>
                        Först och främst så ville jag arbeta med en lite svårare transition (transform i detta fall); så jag tänkte att jag skulle köra på en rotate, då det kändes rätt relevant.<br>
                        Sen visste jag att jag ville arbeta med window-size eller dylikt. Detta användes i mitt fall för att räkna ut var de valda elementen var representerade i relation<br>
                        till mitten av skärmen.<br><br>

                        Nedan följer en enkel beskrivning av vad som gjorts:<br><br>

                        <ol>
                            <li> Användaren trycker på '.' för att trigga eventet </li>
                            <li> De markerade objektens position räknas ut genom att använda <span class="code">el.getBoundingClientRect().left</span> för att se vad objektets "riktiga" <span class="code">offset</span> är.
                                 Sedan används en rätt enkel formula <span code="code"> Math.floor(width / 2) + offset </span> för att hitta elementets mittpunkt i relation till <b>hela</b> skärmens mittpunkt. </li>
                            <li> Den ovan nämnda formulan används sedan för att se utifall objektets <span class="code">offset</span> är mer eller mindre än skärmens mittpunkt. Ett booleanskt värde sätts sedan. </li>
                            <li> Om den booleanska flaggan är mindre än mittpunkten så sätts objektets transition så att objektet skickas åt vänster, annars åt höger. </li>
                            <li> Därefter så sätts en <span class="code">window.setTimeout()</span> för att efter en genomförd transition ta bort objektet </li>
                        </ol>
                        <br>
                        Så en snabb genomgång; objektet beräknar sin position i relation till skärmens mittpunkt. Om den är till vänster av mittpunkten så skickas objektet åt vänster (ut ur skärmen) och <br>
                        snurrar runt ett varv innan elementet tas bort genom en <span class="code">removeChild()</span> som i tidigare uppgift. Om objektet är till höger om mittpunkten så skickas den till höger <br>
                        och snurrar roterar ett varv. <br>
                        <br>
                        Ganska simpelt om man bryter ner uppgiften i mindre delar, men allt som allt så skulle jag vilja påstå att det är en relativt utmanande uppgift i jämförelse med de tidigare uppgifterna.
                        <br><br>

                        <li><b>Berätta hur du tänkte när du gjorde ditt flagg-memory. Gick det bra? </b></li><br><br>
                        Så jag gjorde min lite annorlunda. Dels ville jag göra den lite 'finare' och interaktiv än ursprungsexemplet. Så jag tänkte att jag skulle använda mig av lite transitions<br>
                        och transformations tillsammans med click-events. Överlag gick det bra, dock var det lite krångligt att få upp allting. Logiken är ju rätt lätt att skapa, men<br>
                        det var lite jobbigare att skapa spelbrädet.<br><br>

                        Som nämnt ovan så var det ett par saker jag ville göra bättre än exemplet.<br>
                        Dels ville jag jobba mer med DOM-element snarare än att rita varje memory-card när de klickas, som i exemplet.<br><br>

                        Så för att lösa det så skapar jag först en tom array (10 element, spelbrädet) samt en nodeList med alla .flip-containers (också 1 element). Sen mappade jag dem<br>
                        genom att ge varje element i den tomma arrayen ett nummer mellan 1 och 5 (ett nummer för varje kort, en dublett av varje). Arrayen tillsammans med min NodeList<br>
                        mappades sedan till en karta beroende på NodeListens plats i arrayen. Lite som en enkel variant av en linkedlist. Här är ett exempel:<br><br>
                        <ul>
                            <li>Min Array:</li>
                            [1,2,3,4,5,1,2,3,4,5]
                            <li>Min NodeList</li>
                            [0,1,2,3,4,5,6,7,8,9]
                        </ul><br><br>
                        Sen har vi min case-switch som alltså går igenom min NodeList och kollar vad dess respektive plats i arrayen är för att se vilken flagga som den bör ha.<br>
                        Så säg Array[NodeList[0].id] = 1, vilket är den svenska flaggan, eller Array[NodeList[9].id] = 5 vilket är den finska flaggan.<br><br>


                        Sen nämnde jag även att jag ville göra det lite finare. Detta gjorde jag genom att definiera specifika transitions och transformY i min .css. Detta är rätt<br>
                        basic css3(d) där vi arbetar med perspective och Y-axis. Det skapar en rätt läcker flip-card animation lik den jag har på min <a href="http://portfolio.kimput.com">hemsida</a>.<br>
                        Dock är skillnaden i detta fall att jag valt att använda mig av click-events för att binda varje element till en animation när de blir klickade.<br>
                        Igen, ingenting speciellt. Men det gör det lite mer interaktivt för spelaren vilket kanske kan uppskattas.<br><br>

                        <b>Ett problem, dock</b> är att jag inte tillämpat en felsäker logik. Det innebär att om en användare börjar spamma flaggor så kommer vissa av dem kanske fastna. Något<br>
                        som egentligen inte borde hända, men jag tror inte det förstör spelet. Det enda man ska tänka på då är att man klickar på de flaggorna som 'glitchat' för att de ska<br><br>
                        resettas.
                        Jag skulle dock vilja påstå att det är viktigare att spelet ser bra ut i detta fall. Spelet fungerar som det ska, all logik finns där. Men <b>OM</b> spelaren vill<br>
                        förstöra spelet, så kan han / hon göra det. Dock känns det inte helt relevant att se till att spelaren inte <b>KAN</b> förstöra spelet, utan viktigare att spelet är kul,<br>
                        interaktivt och spelbart så länge spelaren följer de normaliserade reglerna i memory. :)<br><br>

                        <li><b>Vad anser du om Crockfords videor, har du tittat på dem?</b></li><br><br>
                        Nej, det har jag inte. Jag hoppas jag inte får mindre poäng från ett redovisningsperspektiv för att jag inte uttrycker mig bättre ang. detta. Det är inte ett formellt<br>
                        krav att ha sett på videorna och eftersom jag inte riktigt fastnat på något så har jag inte behövt se över kursmaterialet än...<br>
                   </ul>
            </div>
        </div>
    </div>

    <div class="panel panel-default">
        <div class="panel-heading">
            <h4 class="panel-title">
            <a data-toggle="collapse" data-parent="#redovisnings-grupp" href="#Kmom06">Kmom06</a>
            </h4>
        </div>
        <div id="Kmom06" class="panel-collapse collapse">
            <div class="panel-body">
                    <ul>

                        <li><b>Har du några erfarenheter av design mönster sedan tidigare?</b></li><br><br>
                        Jo, men det har jag. Inte alltför mycket rent formell erfarenhet, men nog har jag jobbat med designmönster tidigare.<br>
                        Det sättet jag löste projektet i Python är ett rätt bra sätt att visa att jag har gjort det. Sen har jag försökt lösa samtliga javascripts moment så<br>
                        dynamiskt som möjligt, detta genom att arbeta med starkt typade mönster (objekt) som gör det lättare att ta bort och lägga till bitar till uppgifterna.<br><br>

                        Det gör det överlag rätt mycket bekvämare när man har ordentligt "strong typed" objekt så att det blir lättare att spinna vidare. Problemet med<br>
                        starkt typade objekt och designmönster är dock att det behövs lägga ner så mycket tid att designa dem innan man kan börja implementera kod.<br><br>

                        Det märkte jag rätt tydligt i Python-kursen, då jag la till och tog bort delar i mina olika objekt under utvecklingstiden, vilket i slutändan gjorde<br>
                        det väldigt svårt för mig att fortsätta ner den linjen och vilket till slut fick mig att skrota det mesta till fördel att ha en ny, mer dynamisk lösning.<br><br>


                        <li><b>Var det svårt att greppa hur function scope och closure fungerar eller känns det naturligt?</b></li><br><br>

                        Det känns överlag rätt naturligt. Jag har ju jobbat med de här sakerna tidigare, så scopes känns väldigt naturligt.<br>
                        Jag hade det lite svårt att förstå hur jag skulle anropa saker i den bifogade hangman-filen (hangman.js), men efter att ha klurat runt hur det skulle lösas en bra stund<br>
                        så insåg jag att jag hade missat en bracket (")") i slutet av min onload. Känns ju lagom smart, men man lär sig så länge man lever...<br><br>

                        I slutändan började jag förstå hur man skulle arbeta med closure osv, dock. Det var lite småsvårt till att börja med, mest för att jag inte hade full koll på hur man jobbar med<br>
                        consolen tillsammans med JS, alltså med input från consolen. Det var riktigt kul när man förstod det, dock! <br>
                        Min kodstruktur är rätt intressant, dock. Hangman fungerar som en class skulle gjort i java, dvs att man arbetar med den genom att köra Hangman.hangman.show() för att nå <br>
                        hangmans publika funktioner (show, hide). <br>
                        Som svar på extrauppgiften (kunna spela spelet från konsolen) så har ni tillgång till <span class="code"> Hangman.guess(letter) </span>. Denna fungerar mycket som wordlist och<br>
                        peek, med skillnad att den kräver två variabler (gissningen och en referens till att gissningen skickats från konsolen). <br><br>

                        En annan sak som gjorde det lite svårt var att jag var tvungen att hantera consol-gissningarna lite annorlunda då jag var tvungen att hitta DOM-objekten manuellt för att <br>
                        markera att de har blivit gissade och för att säkerställa att tidigare gissningar ses över inanan den nya används. Dvs. om du skriver 'a' och 'a' redan har gissats, så <br>
                        behöver det registreras på något sätt. I de none-console gissningarna så har jag en event-listener som ser över "click" och på så vis sätter 'focus' på den knappen <br>
                        som klickats på. <br><br>

                        <li><b>Kan du jämföra “module pattern” med någon annat liknande datastruktur?</b></li><br><br>
                        Det är inget specifikt just för JS, om jag ska vara helt ärlig. Det handlar ju egentligen om att man kan ha ett gäng moduler och det som finns i modulens scope inte<br>
                        kan tillgås utanför modulen (module scope).<br>
                        Om vi ska jämföra module pattern med något annat så är det väl rätt enkelt att likna det vid objekt eller klasser i andra språk, där en klass kan ha x specifika moduler<br>
                        och n variabler som endast kan nås via antingen get-methods eller som är instansierade just i dess scope, om inte annat specifierat.<br><br>

                        <li><b>Känns “module pattern som en bra kodstruktur”?</b></li><br><br>
                        Jo, men det är det ju självklart. Det är som sagt en rätt basic struktur där man bryter ner en massa kod i moduler för att säkerställa att kod som INTE ska kunnas nås<br>
                        inte kan nås (private variabler) eller för att ge kod en mer strukturerad (mer lättläst) struktur. Det gör det lättare för personer att läsa, att förstå men ökar<br>
                        även produktionen, då man har tillgång till att göra 'mer' när ens kod är korrekt strukturerad. Ett lätt exempel är ju när man använder funktioner<br>
                        som tillåter en utvecklare att skriva 'mindre' kod. <br>
                   </ul>
            </div>
        </div>
    </div>

    <div class="panel panel-default">
        <div class="panel-heading">
            <h4 class="panel-title">
            <a data-toggle="collapse" data-parent="#redovisnings-grupp" href="#Kmom10">Kmom10</a>
            </h4>
        </div>
        <div id="Kmom10" class="panel-collapse collapse">
            <div class="panel-body">
                    <ul>

                        <li><b>Delmoment</b></li><br><br>
                        <h2> Inledning </h2>
                        <br>
                        Först och främst gissar jag på att ni kommer vilja se över källkoden, vilken ni kan se här: <br>
                        <a href="https://github.com/Todai88/bth_javascript"><strong>BTH_javascript på Github</strong></a>.
                        <br>
                        Jag har valt att följa samma struktur som vi gjort i kursen; de första 3 testen fungerar som <br>
                        de tidigare labbarna, med lite mer primitiv javascript-kod. Något som många anser vara 'bad' practice nu.<br>
                        Dvs. innerHTML sätts under exekvering osv. Dels är det ju en säkerhetsrisk, men det är även riktigt dåligt<br>
                        för produktiviteten.<br>
                        <br>
                        Jag vill dock att ni förstår att jag gjort detta för att jag ville lära mig hur mer primitiv JS funkar, <br>
                        inte för att jag vanligtvis skulle använda mig av sådan kod. <br><br>
                        Därför har jag använt mig av mer modern (bättre) kod i de senare spelen (4,5). <br>
                        Där har jag väldigt sparsamt använt mig av innerHTML, endast för att skapa parent-objects <br>
                        för mina noder. <br>
                        <br>
                        Jag använder mig av två huvudsakliga divar, en för reglerna och information om spelet ('rules') <br>
                        och en för spelet ('gameboard').<br>
                        'Rules' används för att ge övergripande information om testet både innan det börjar och under dess exekvering. <br>
                        Detta fungerar alltså som hjälpmeddelandet som nämns i specen och finns i alla fall det 'behövs' innan testet börjar.<br>
                        'Gameboard' används som ett spelbräde som får objekt allokerat till sig och rensas innan varje nytt moment. <br>
                        Dessa två divar används i princip som grandparent-objects, de används för att skapa divar (parents) <br>
                        och dess associerade objekt (children).<br>
                        De divarna är alltså min 'sida' och används som specifierat i speccen som parents för mitt dynamiska innehåll.
                        <br>
                        <br>
                        Sen har vi även 'Test', som är specifierat att använda för att ge lite 'fusk'-tillgång i spelet.<br>
                        Jag har valt att göra 'Test' betydligt mer avancerad än vad som specifierat;<br>
                        Du kan exempelvis använda dig av Test för att få ut svaren på ditt nuvarande test, eller för att gå mellan<br>
                        spel, resetta spel, få ut din nuvarande poäng globalt eller specifikt denna omgången.<br>
                        <br>
                        Test objektet är helt enkelt där för att hjälpa dig under din tid i spelet.<br>
                        Test visar även en hjälpsträng när du börjar första testet. Den strängen kan anropas via Test.help() vid senare test. <br>
                        <br>
                        Uträkningen av intelligens är väldigt simpel; jag använder mig av den poängsättningen som specificerats i specen:<br> <br>
                        1: 3 frågor, vardera värd 3 poäng  (9),<br>
                        2: Rätt svar ger 3 poäng           (3),<br>
                        3: 9 flaggor, vardera värd 1 poäng (9),<br>
                        4: 10 objekt, vardera värd 1 poäng (10),<br>
                        5: 10 objekt, vardera värd 1 poäng (10)<br><br>
                        Sammanlagt blir det 41 (9 + 3 + 9 + 10 + 10) poäng. <br>
                        <br>
                        I slutet av testet så visas ens slutpoäng tillsammans med maxpoängen.
                        <br><br>

                        <ol>
                            <li> <b>Tipsfrågor</b> </li><br>

                            Här visas tre frågor, efter vad specens krav; vardera värd tre poäng. <br><br>
                            Frågorna är egentligen ett objekt (game_object) av objekt (question).
                            Varje question-objekt har dess tre möjliga alternativ samt det korrekta alternativet.<br>
                            Dessa tre frågor använder sig av radiobuttons, vilka har sin text inom 'labels',
                            alltså fungerar varje radiobutton som en nod för sig, med ett barn som är en 'label'. <br>
                            Anledningen till att jag valt att gå den rutten är för att jag visar vilket svar som var rätt
                            genom att ändra färgen på den 'label':n som tillhör det rätta svaret till grönt, och de andra två
                            blir röda. <br>
                            Rätt simpelt lagt så testas alltså värdet labeln från den radiobutton som klickats mot det rätta svaret
                            i radiobutton-gruppens associerade question-objekt.<br>
                            Som nämnt i inledningen så är koden rätt primitiv, där jag sätter många av div-elementen osv rätt i innerHTML.<
                            Något som överlag ses som 'bad' practice. Jag nämner även ovan varför jag valde att göra på så vis.
                            <br><br>
                            Utöver ovan beskrivning så är första testet rätt basic, användaren ska kunna klicka på en gissning och korrekt svar
                            ska visas direkt (enligt specen). Så mitt sätt att göra detta är att skapa ett 'click'-event som fångar användarens klick
                            och disablar den klickade gruppen och visar rätt svar (enligt ovan). <br><br>
                            Vid valfrit tillfälle kan användaren välja att navigera bort från testet genom att klicka på knappen nere till höger.<br><br>



                        <li><b>FizzBuzz</b></li><br><br>

                        Här börjar det bli lite mer avancerat, dock inte riktigt svårt än. <br>
                        Jag börjar med att skapa en slumpmässig sekvens av nummer som jag sparar i en lista. Sedan iterarar jag över listan för att säkerställa att det
                        finns åtminstone 2 objekt som kan fungera som fizz, fizzbuzz eller buzz. Utifall det finns fler än 2 så används ännu en Math.random för att hitta
                        2 slumpmässiga av de möjliga talen. <br>
                        Tanken med det var att jag ville ha det så dynamiskt som möjligt, mer för mig själv än för testet. Första testet var ju så satans statiskt, så
                        det kändes viktigt för mig att göra något lite mer dynamiskt. <br>
                        Efter att sekvensen är skapad skapas ännu en lista, denna gång av strängar, som innehåller de möjliga gissningarna. Här är det självklart viktigt
                        att man har med sig de två korrekta numren från den ursprungliga sekvensen. <br>
                        Efter att listan är skapad så skapas en unordered list med list-style-type 'none' för att ta bort någon slags 'decoration' och sedan
                        tas strängarna från listan och så skapan listelement 'li' med varsitt DOM-element (button) med textNode(strängen). Rätt simpelt, eller hur? <br>
                        Självklart får även varje DOM-element sin egen eventListener som tester utifall ditt svar var korrekt.<br>
                        Därefter får du se vilket svar var korrekt och kan navigera till nästa spel.<br>
                        <br>

                        <li><b>Minne</b></li><br><br>
                        Detta test var nog det jag hade mest problem med, antagligen för att jag var dum nog att fortätta att använda primitiv javascript-kod. <br>
                        Här började alltså addEventListeners osv börja bli lite jobbigt att jobba med då jag inte allting var noder osv, utan vissa objekt var specifikt
                        deklarerade (strong-typed) i innerHTML. Detta gjorde det svårt att veta just när JavaScripts UI-tråd når vad, vilket kunde leda till att en
                        addEventListener antingen blev associerad med fel objekt, eller att det objektet jag ville att den skulle associeras med inte fanns övht.<br>
                        Det blev även lite svårare när man väl börjar jobba med addEventListeners och setTimeout-event, då man inte riktigt vet var UI-tråden kommer dra iväg.
                        Jag visste inte ursprungligen att ett setTimeout-event helt enkelt sätter en flagga på raden och sedan forstätter exekvera tills dess att tiden tagit
                        slut och sedan går tillbaka till den flaggade raden.<br><br>
                        Exempelvis detta:<br>
                        <span class="code">
                        var par = document.getElementById('parent');<br>
                        var button = document.createElement('button');<br>
                        var txt = document.createTextNode('Tester');<br>
                        button.appendChild(txt);<br>
                        window.setTimeout(function(){<br>
                        	par.appendChild(button);<br>
                        }, 3000);<br>
                        button.addEventListener('click', function(){<br>
                        alert('clicked');<br>
                        });
                        </span><br><br>
                        Urprungligen hade jag trott att i koden ovan hade UI-tråden 'stannat' kvar i setTimeout-eventet, medans egentligen så forsätter den alltså iterara
                        över all kod och väntar med att gå in i setTimeout-eventet. Dvs att i mitt fall, då jag använde mig av 'skitkod' avsiktligen, för att lära mig,
                        (igen, alltså innerHTML osv), så hände det alltså att jag hade null-pointers, alltså referarade till objekt som inte fanns, då de inte funnits
                        i ren och skär HTML-kod. <br>
                        Som sagt så var det ett medvetet misstag att använda mig av den ovan nämnda 'skitkoden'. För att helt enkelt lära mig av dess kortkommanden;
                        när och hur problem uppstår när man använder sig av så kallad primitiv kod.<br>
                        <br>
                        Rent tekniskt sätt så använde jag mig alltså av först ett tomt gameboard där användaren har möjlighet att spana igenom reglerna och sedan starta timern(5s).<br>
                        Därefter så visas flaggorna faceup så att användaren har möjlighet att lära sig var vardera flagga är. <br>
                        Efter att timern löpt ut så skapas en shufflad lista (enligt Fisher-Yates algoritmen) med vardera associerad flagga i, men i en annan ordning. <br>
                        Denna listan visas efter en sekund efter att flaggorna lagts backup, så att säga. <br>
                        <br>
                        I denna uppgift återanvände jag mig av en liten del av koden från flag4, men nästan ALL css-kod för att hantera transitions osv. <br>
                        Utöver det så la jag till lite kod i min eventListener, så att varje flagga som klickats förlorar sin eventListener, för att motverka 'fusk'. <br>
                        Den slumpmässigt genererade listan är också rätt cool. Där använder jag mig av riktiga DOM-objekt och itererar igenom listan för varje rätt svar.
                        Om det är rätt svar ändras alltså klasslistan och lite snygg text-dekoration animeras, som en liten scroll typ.
                        <br>
                        Det kan vara värt att nämna att Test.get_answer() visar listan på vilka flaggor ligger på vilken plats, för att göra det lite lättare för er att testa.
                        <br>
                        Man får även ett lite fint meddelande om man lyckas få alla korrekta flaggor. Försök, utan att fuska! ;)
                        <br><br>
                        <li><b>Visuell intelligens</b></li>
                        Här börjar det verkligen bli lite jobbigt (alltså på riktigt). <br>
                        Det var på god tid att börja använda sig av lite mer modern JS-kod här, så allting bygger egentligen på noder.
                        Som jag nämnde lite kort ovan så har jag alltså valt att i test 4 och 5 använda mig av noder som klaffar fast vid barn till huvudelementet gameboard. <br>
                        Så i detta fall så används innerHTML ytterst sparsamt, endast för att skapa elementen som jag använder mig av för att sätta fast mina noder vid. <br><br>
                        Innan jag går in på något rent tekniskt vill jag påpeka att det finns en risk att testet inte fungerar väl på vissa skärmar, detta då jag använder mig av
                        mixade storlekar och offsets (px och %). Så om ni stöter på något problem så kan ni enkelt använda er av knappen som säger 'reset' test.
                        <br>Det bör verkligen inte vara någon större fara. Men vid VÄLDIGT få tillfällen så kan det hända att ett objekt ligger helt över ett annat, eller att ett
                        objekt gömmer lite av texten. Men överlag funkar det görbra. :)
                        <br>Gissningsvis så inträffar detta pga att Math.random() fungerar mycket som liknande funktioner i c / c++ då de slumpas fram genom att använda sig av tid (ms)<br>
                        Så det finns alltså en mindre chans att elementen skapas på precis samma plats då de 'spawnas' samtidigt och därmed får samma offsets. <br>
                        Jag upplever inte det som ett större problem, utan något smärre som kanske kan fixas vid ett senare tillfälle. Dock upplever jag det som lite roligare med
                        random offsets osv än att ha objekten i en lista eller liknande då det i mitt fall blir lite mer interaktivt.
                        <br><br>
                        I denna uppgift skapar jag tre olika objekt:
                        <ol>
                            <li>Ett form-objekt</li>
                            Detta objekt används för att skapan en form. Objektet är ett objekt av objekt, där parent-objektet är ett nummer (ett id) och barn-objektet har
                            två nycklar; class (dess associerade css klass(er) - ex 'square') och name (dess namn, används för att skapa list-strängen, se senare).
                            <li>Ett color-objekt</li>
                            Detta objekt precis som form-objektet, med skillnad från att dess klasser är färger, inte former.
                            <li>Spelobjekt</li>
                            Detta objekt är byggt på de andra objekten, alltså fungerar de två andra som interfaces (spelobjektet ärver properties).
                            Objektet skapas med hjälp av en simpel Object.create() där ett slumpmässigt nummer som refererar till barn-objektets ID skickas in.
                            När man skapar spelobjektet så skapas även en sträng som refererar till dess referade objekts namn. <br>
                            Ett exempel kan vara detta: <br>
                            var go = Object.create(game_object, x, y, z); <br>
                            Där x = id, y = form, z = color. y och z > 0 < 5, då det endast finns 4 möjliga former och färger. <br><br>
                        </ol>

                        Efter att en array med spelobjekt skapats dynamiskt så delas gameboard upp i två delar, en övre som fungerar
                        som den egentliga gameboarden samt en undre som fungerar som en lista med namn på de objekt som ska klickas på. <br>
                        Bägge delarna har ENDAST DOM-element i sig som hanteras dynamiskt. Exempelvis har du i top-delen element som tas bort när de klickas på,
                        i den nedre delen har du en lista som ändras allteftersom du klickar på objekt i den övre delen. <br>
                        Du har alltså spelobjekten i den övre delen som alltså får en eventListener på sig. När de klickas så testas dess värden
                        mot det markerade värdet i listan i den nedre delen. Stämmer de, så går försvinner text-decoration av det nuvarande elementet i listan
                        och nästa element i listan får dess decoration samtidgt som det klickade elementet tas bort från spelbrädet. <br> <br>
                        Då jag använde mig av korrekt, modern JS-kod så var det inga större problem som jag stötte på under denna utvecklingsfas. Dock blev det
                        lite jobbigt då jag började testa funktionen eftersom den använder sig av en setTimeout så blev det ursprungligen lite bökigt att få
                        den att fungera väl med Test.reset(). Dock så löste jag det genom att skapa en global timer variabel som fick hålla i timern.<br>
                        Så när timern var igång och Test.reset() invokeras, så kör jag helt enkelt en window.clearTimeout(timer) och en normal reset, vilket då
                        nollställer allting i det testet. Annars var risken överhängande att du alltså påbörjade en ny omgång medans din 'resetade' omgång
                        fortsätter i bakgrunden.<br>
                        Detta var även ett litet bekymmer när man kör Test.go_to() och navigerar iväg från den funktionen när man har den startad. Då inträffade
                        samma sak som inträffade vid reset(), alltså att ditt förra spel fortsätter i bakgrunden. Det löstes på samma sätt, dock.<br><br>

                        <li><b> Uppfattningsförmåga </b></li>
                        <br><br>
                            Efter att ha genomfört visuell intelligens så blev detta betydligt lättare. <br>
                            Problemet i detta är självklart hur man ska hantera sina timed-events. De skelettet av delmomentet redan är klart, så slipper
                            man ju skapa objekt osv (som sagt är skelettet klart).<br><br>
                            Men som nämnt så var det lite bekymmer med timed-events. I början tänkte jag att jag skulle ha en loop runt en timeout för att iterera över en lista av spelobjekt,
                            men självklart blev det bekymmer då loopen helt enkelt kör igenom alla objekt utan att gå in i dem (som nämnt ovan). Istället för att köra in i loopen,
                            ta ut första objektet, vänta en sekund, loopa igen etc etc, så gick alltså UI-tråden igenom hela listan för att sedan pumpa ut alla objekt samtidigt.
                            <br>
                            Min lösning är lite mer... kaxig. Eftersom jag har rätt god erfarenhet av en hel del programmeringsspråk på en hel del olika nivåer, så tänkte jag att jag
                            skulle köra med en funktions-variabel som skulle fungera som en iterator och sedan iterera över listan genom att använda mig av recursion.
                            <br>
                            Så jag skapade alltså en funktion kallad <span class="code">show_object(objects, iterator)</span> som hade två separata timers.
                            Första timern kallas och tömmer spelbrädet (tar bort det förra objektet), sätter en booleansk variabel kalled 'clicked'
                            till false (för att se om objektet blir klickat) och skapar den andra timern. Den andra timern visar det nya objektet under en sekund
                            sedan kallas <span class="code">show_objects(objects, iterator + 1)</span> igen, men med en inkrementerad iterator. <br>
                            Som nämnt ovan i förra delmomentets redovisning så skapade jag även timer2 som en ny timer-variabel. Detta för att säkerställa
                            att en Test.reset() rensar timer2's timingEvents. Utöver det var jag även tvungen att implementera en stop_flag(boolean) för att
                            säkerställa att alla redan startade function calls till show_object skulle sluta utifall man kör en Test.reset() <br><br>
                            Varje objekt får sin egen eventListener som kollar utifall objektet är ett bra eller dåligt objekt, om det är dåligt ska det klickas på. Annars ska det inte klickas på.
                            Kan du gissa vad som händer med 'clicked' (boolean flaggan som nämndes ovan) när objektet blir klickat? Exakt, det blir alltså markerat som 'true' och
                            i slutet av iterationen (innan functionen rekursivt blir kallad igen), så kollar vi utifall objektet var bra eller dåligt. Var det dåligt och inte blev
                            klickat så får du en poäng, annars blir det dålig stämning. :(<br>
                        </ol>
                        <br><br>
                        <li><b> Tankar om projektet </b></li><br><br>
                        Till att börja med vill jag påpeka att det var ett riktigt roligt och något lärorikt projekt att jobba med.<br>
                        <h3>Svårighetsgrad:</h3>
                        Överlag var det inte ett alltför svårt projekt att jobba med. Jag tror dock att det är viktigt att se på helheltsbilden;
                        jag hade de flesta bitarna för att kunna skapa alla delar av projektet, men det svåra för att implementera samtliga saker på rätt sätt.
                        Det jag menar är att delmomenten inte var alltför svåra om man ser på dem separat. Dock blev de lite bökigare när man började tänka på hur
                        man ska kunna använda Test-funktionerna osv. Jag gick ju rätt långt med mina funktioner, då jag ville kunna arbeta med dem på diverse olika sätt;
                        göra det lättare för mig att debugga, för att hoppa mellan spel, ge mig svar osv.
                        <br>
                        Jag tror dock de flesta hade något eller några problem med timing-eventen oc hur de skulle implementera allt med dem korrekt i delmomenten.
                        Om man inte hade implmenterat en korrekt struktur, så blev det jobbigt att implementera bra events. För mig specifikt blev det
                        riktigt svårt för mig att hantera eventListeners, timeout osv i de tidigare delmomenten då jag medvetet valt att jobba med den 'primitiva'
                        JS-koden.<br>
                        Men som sagt tror jag att de separata delmomenten kunde varit lite svårare, eftersom det som egentligen gjorde det svårt var att hantera
                        saker som hade lite mindre med delmomenten att göra och mer att göra med kodstrukturen.
                        <br>
                        <h3>Problem:</h3>
                        Jag tror inte jag hade alltför många problem utöver de som jag nämnt ovan i delmomenten. <br>
                        Det var väl vissa väldigt specifika saker som ibland kunde vara lite problematiska. Dock ingenting som jag kommer på så här på rak arm.<br>
                        Så jag får nog hänvisa till delmomenten för mer specifika tankar.
                        <h3>Tid:</h3>
                        Jag har varit rätt upptagen under större delen av december, dels med familj och vänner - men även med jobb. Jag är nu ansvarig för utvecklingen av
                        vara appar, så det har varit rätt mycket att göra. <br>
                        Dock var det rätt skönt att projektet var rätt snabbt och lätt att genomföra. Jag har kämpat mig igenom större del av det över helgen och
                        är väldigt nöjd med slutprodukten. <br>
                        Jag måste alltså erkänna att det var ett rätt snabbt genomförande av projektet.
                        <h3>Övriga tankar:</h3>
                        Överlag har det varit ett roligt projekt att jobba med. Det har varit intressant att se hur de tidigare delarna av kursen tagit del i projektet.
                        Som jag nämnt ett par gånger kan jag tycka att de individuella delmomenten i projektet har varit lite lätta. Det jag menar det med är att de var
                        lätta rent tekniskt sett. Dock tog vissa delar som är lätta relativt lång tid att genomföra då man fortfarande behöver skriva en hel del.
                        <br>
                        Ett litet tips är alltså att kanske göra något lite mer komplext till nästa gång.<br>
                        Två specifika saker som jag saknade var dock:<br><br>
                        <ol>
                            <li>Baddie</li>
                            Jag hade velat arbeta vidare på något likt baddie. Mest för att det nu kan kännas som att man lärde sig keycodes utan någon riktig anledning.
                            <br><br>
                            <b>OCH</b>
                            <br><br>
                            <li>Andra valbara delmomentet</li>
                            Detta var väl det som egentligen var mest tekniskt komplext. Men jag hade velat se er göra något som kanske var lite annorlunda från
                            det första valfria delmomentet. Här kanske det skulle kunnat vara något med baddie istället?<br>
                            Eller något som helt enkelt är tekniskt annorlunda än att arbeta med klick-events och setTimeouts.
                        </ol>
                        <br>

                        <li><b>Tankar om kursen</b></li><br><br>
                        Jag har gillat kursen skarpt. Den var betydligt mycket roligare än Python-kursen. Dessutom så gav den mig nog mer rent personligen också.
                        Javascript är ett sådant globalt språk att alla kommer att ha hört om det och de används till sådan stor grad här i England.<br>
                        Handledningen har känts bra, det har inte varit några problem alls. Jag har redan rekommenderat kurspaketet för ett par vänner vid Chalmers
                        då jag känner att paketet har gett mig rätt god praktisk erfarenhet inom saker jag annars kanske endast hade sett på rent teoretiskt.<br>
                        Jag ger kursen en solklar 9/10. Det enda som jag kan tycka sänker kursen lite är de valfria delmomenten i projektet (se ovan).
                   </ul>
            </div>
        </div>
    </div>

    	</div>
    	</div>

<script type="text/javascript" src="js/main.js"></script>
</body>
</html>
